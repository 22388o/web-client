{"version":3,"sources":["utils/Cache.js","utils/Promise.js","utils/Torrents.js","images/av1.jpg","hooks/useOnlineStatus.js","common/TipModal/index.js","common/NavBar/index.js","pages/Post/index.js"],"names":["getCachedFile","fileName","a","FileCache","_init","Promise","resolve","reject","init","then","console","log","persist","status","persistent","load","cachedFile","createURL","warn","renderCachedFile","fileURL","selector","elements","document","querySelectorAll","length","forEach","element","src","muted","autoplay","saveFile","buffer","save","runSerial","tasks","result","task","supportedFileTypes","formats","options","_getFileType","file","extension","name","split","slice","Object","entries","filter","includes","supportedFileType","fileType","webTorrentClient","initializeClient","WebTorrent","default","attachMedia","posts","torrentMode","all","map","post","contentItems","id","supportedItems","item","type","key","get","magnetURI","add","torrent","files","target","destroy","torrentElements","torrentElement","contentURL","decodeURIComponent","replace","format","toLowerCase","endsWith","compatibleURL","setAttribute","renderTo","on","getBlob","err","blob","querySelector","dataset","played","torrentTasks","reduce","torrents","module","exports","useOnlineStatus","publicKey","dispatch","useDispatch","profile","useSelector","user","useState","lastSeenApp","setLastSeenApp","lastSeenNode","setLastSeenNode","isOnlineApp","setIsOnlineApp","isOnlineNode","setIsOnlineNode","onlineCheckTimer","setOnlineCheckTimer","updateUserStatus","useCallback","onlineThreshold","Moment","utc","subtract","isSameOrAfter","useEffect","clearTimeout","timer","setTimeout","lastSeenAppListener","listenPath","path","gunPointer","gunUser","callback","event","lastSeenNodeListener","off","TipModalContent","React","lazy","TipModal","props","modalOpen","tip","close","closeModal","loader","useMemo","text","className","onClick","fallback","placeholderIcon","NavBar","title","goBack","Post","SharedPost","PostPage","useParams","postId","userId","history","useHistory","pinnedPost","wall","loading","setLoading","username","displayName","alias","fetchUser","resetUserData","getUserProfile","getUserAvatar","fetchSelectedPost","getPinnedPost","initializeData","push","renderPost","avatar","av1","Loader","postID","postPublicKey","originalAuthor","sharedPostId","sharedTimestamp","date","sharerAvatar","sharerPublicKey","sharerUsername","timestamp","page","tipValue","tipCounter","pinned"],"mappings":"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","file":"static/js/11.860dd8e3.chunk.js","sourcesContent":["import FileCache from \"browser-file-storage\";\n\nexport const DB_NAME = \"ShockWalletStore\";\n\nexport const init = () =>\n  new Promise((resolve, reject) => {\n    FileCache.init(DB_NAME)\n      .then(() => {\n        console.log(\"File cache initialized!\");\n        return FileCache.persist();\n      })\n      .then(status => {\n        if (status.persistent) {\n          resolve(status);\n        } else {\n          reject(status);\n        }\n      });\n  });\n\nexport const getCachedFile = async fileName => {\n  try {\n    if (!FileCache._init) {\n      await init();\n    }\n\n    const cachedFile = await FileCache.load(fileName);\n    return cachedFile.createURL();\n  } catch (err) {\n    console.warn(err);\n    return false;\n  }\n};\n\nexport const renderCachedFile = (fileURL, selector) => {\n  const elements = document.querySelectorAll(selector);\n  if (elements && elements.length) {\n    elements.forEach(element => {\n      element.src = fileURL;\n      element.muted = true;\n      element.autoplay = true;\n    });\n  }\n  return !!elements && !!elements.length;\n};\n\nexport const saveFile = (fileName, buffer) => {\n  return FileCache.save(fileName, buffer);\n};\n","export const runSerial = tasks => {\n  let result = Promise.resolve();\n  tasks.forEach(task => {\n    result = result.then(() => task());\n  });\n  return result;\n};\n","import { getCachedFile, renderCachedFile, saveFile } from \"./Cache\";\nimport { runSerial } from \"./Promise\";\n\nconst supportedFileTypes = {\n  \"video/embedded\": {\n    formats: [\"mp4\", \"webm\"],\n    element: \"video\",\n    options: {\n      autoplay: true,\n      muted: true\n    }\n  },\n  \"image/embedded\": {\n    formats: [\"jpg\", \"png\", \"webp\", \"jpeg\"],\n    element: \"img\",\n    options: {}\n  }\n};\n\nconst _getFileType = file => {\n  const extension = file.name?.split(\".\")?.slice(-1)[0];\n  const [supportedFileType] = Object.entries(supportedFileTypes).filter(\n    ([type, options]) => options.formats.includes(extension)\n  );\n\n  if (supportedFileType) {\n    const [name, fileType] = supportedFileType;\n    return {\n      name,\n      ...fileType\n    };\n  }\n\n  return null;\n};\n\nexport let webTorrentClient = null;\n\nexport const initializeClient = async () => {\n  if (!webTorrentClient) {\n    const WebTorrent = await import(\"webtorrent\");\n    webTorrentClient = new WebTorrent.default();\n  }\n\n  return webTorrentClient;\n};\n\nexport const attachMedia = async (posts = [], torrentMode = true) => {\n  const torrentTasks = await Promise.all(\n    posts.map(async post => {\n      const { contentItems, id } = post;\n      const supportedItems = Object.entries(contentItems).filter(\n        ([, item]) => supportedFileTypes[item.type]\n      );\n\n      if (!supportedItems) {\n        return [];\n      }\n\n      const webTorrentClient = await initializeClient();\n\n      return supportedItems.map(\n        ([key, item]) =>\n          () =>\n            new Promise(resolve => {\n              const torrentExists = webTorrentClient.get(item.magnetURI);\n\n              if (torrentExists) {\n                resolve(true);\n                return;\n              }\n\n              webTorrentClient.add(item.magnetURI, async torrent => {\n                // Proceed to the next torrent in queue\n                resolve(true);\n\n                const files = torrent.files.filter(file => {\n                  const extension = file.name?.split(\".\")?.slice(-1)[0];\n                  const supportedFileType = Object.entries(\n                    supportedFileTypes\n                  ).filter(([, options]) =>\n                    options.formats.includes(extension)\n                  )[0];\n                  if (supportedFileType) {\n                    const [, fileType] = supportedFileType;\n                    const matched = fileType.formats.includes(extension);\n                    return matched;\n                  }\n                  return false;\n                });\n\n                files.map(async file => {\n                  const fileType = _getFileType(file);\n\n                  if (!fileType) {\n                    return;\n                  }\n\n                  const fileName = `${id}-${key}-${file.name}`;\n\n                  const element = fileType.element;\n                  const target = `${element}[data-torrent=\"${item.magnetURI}\"]`;\n                  const cachedFile = await getCachedFile(fileName);\n\n                  if (cachedFile) {\n                    const torrent = webTorrentClient.get(item.magnetURI);\n\n                    if (torrent) {\n                      torrent.destroy();\n                    }\n\n                    renderCachedFile(cachedFile, target);\n                    return;\n                  }\n\n                  const torrentElements = document.querySelectorAll(target);\n                  console.log(\"Torrent Elements:\", torrentElements);\n                  torrentElements.forEach(torrentElement => {\n                    const contentURL = decodeURIComponent(\n                      item.magnetURI.replace(/.*(ws=)/gi, \"\")\n                    );\n                    const [compatibleURL] = fileType.formats.filter(format =>\n                      contentURL\n                        .toLowerCase()\n                        .endsWith(`.${format.toLowerCase()}`)\n                    );\n\n                    if (torrentMode || !compatibleURL) {\n                      file.renderTo(torrentElement, fileType.options);\n                      return;\n                    }\n\n                    torrentElement.setAttribute(\"src\", contentURL);\n                  });\n                });\n\n                torrent.on(\"done\", () => {\n                  files.map(file => {\n                    const fileType = _getFileType(file);\n                    const fileName = `${id}-${key}-${file.name}`;\n                    const element = fileType.element;\n                    const target = `${element}[data-torrent=\"${item.magnetURI}\"]`;\n\n                    file.getBlob(async (err, blob) => {\n                      if (err) {\n                        console.warn(err);\n                        return;\n                      }\n\n                      console.log(\"Caching loaded file...\", fileName, blob);\n                      await saveFile(fileName, blob);\n                      const element = document.querySelector(target);\n                      if (element.dataset.played === \"false\") {\n                        const cachedFile = await getCachedFile(fileName);\n                        renderCachedFile(cachedFile, target);\n                      }\n                    });\n                  });\n                });\n              });\n            })\n      );\n    })\n  );\n  const contentItems = torrentTasks.reduce(\n    (torrents, contentItems) => [...torrents, ...contentItems],\n    []\n  );\n\n  runSerial(contentItems);\n};\n","module.exports = __webpack_public_path__ + \"static/media/av1.48bf5c6a.jpg\";","import { useCallback, useEffect, useState } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport Moment from \"moment\";\nimport { gunUser, listenPath } from \"../utils/Gun\";\n\nconst ONLINE_INTERVAL = 30 * 1000;\n\nconst useOnlineStatus = publicKey => {\n  const dispatch = useDispatch();\n  const profile = useSelector(({ user }) => user.profile);\n\n  const [lastSeenApp, setLastSeenApp] = useState(false);\n  const [lastSeenNode, setLastSeenNode] = useState(false);\n  const [isOnlineApp, setIsOnlineApp] = useState(false);\n  const [isOnlineNode, setIsOnlineNode] = useState(false);\n  const [onlineCheckTimer, setOnlineCheckTimer] = useState();\n\n  const updateUserStatus = useCallback(() => {\n    const onlineThreshold = Moment.utc().subtract(1, \"minutes\");\n    const isOnlineNode =\n      Moment.utc(lastSeenNode).isSameOrAfter(onlineThreshold);\n    const isOnlineApp = Moment.utc(lastSeenApp).isSameOrAfter(onlineThreshold);\n\n    setIsOnlineNode(isOnlineNode);\n    setIsOnlineApp(isOnlineApp);\n  }, [lastSeenApp, lastSeenNode]);\n\n  useEffect(() => {\n    if (onlineCheckTimer) {\n      clearTimeout(onlineCheckTimer);\n    }\n\n    updateUserStatus();\n\n    const timer = setTimeout(() => {\n      updateUserStatus();\n    }, ONLINE_INTERVAL);\n\n    setOnlineCheckTimer(timer);\n\n    return () => clearTimeout(onlineCheckTimer);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [profile, updateUserStatus]);\n\n  useEffect(() => {\n    const lastSeenAppListener = listenPath({\n      path: \"Profile/lastSeenApp\",\n      gunPointer: gunUser(publicKey),\n      callback: event => {\n        setLastSeenApp(event);\n      }\n    });\n\n    const lastSeenNodeListener = listenPath({\n      path: \"Profile/lastSeenNode\",\n      gunPointer: gunUser(publicKey),\n      callback: event => {\n        setLastSeenNode(event);\n      }\n    });\n\n    return () => {\n      lastSeenAppListener.off();\n      lastSeenNodeListener.off();\n    };\n  }, [dispatch, publicKey]);\n\n  return {\n    isOnlineApp,\n    isOnlineNode\n  };\n};\n\nexport default useOnlineStatus;\n","import React, { Suspense, useCallback, useMemo } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { closeModal } from \"../../actions/TipActions\";\nimport Loader from \"../Loader\";\nimport \"./css/index.css\";\n\nconst TipModalContent = React.lazy(() => import(\"./components/Modal\"));\n\nconst TipModal = props => {\n  const dispatch = useDispatch();\n  const modalOpen = useSelector(({ tip }) => tip.modalOpen);\n\n  const close = useCallback(() => {\n    dispatch(closeModal());\n  }, [dispatch]);\n\n  const loader = useMemo(() => <Loader text=\"Loading...\" />, []);\n\n  if (!modalOpen) {\n    return null;\n  }\n\n  return (\n    <div className=\"modal-container\">\n      <div className=\"modal-overlay\" onClick={close}></div>\n      <div className=\"modal-content\">\n        <Suspense fallback={loader}>\n          <TipModalContent {...props} />\n        </Suspense>\n      </div>\n    </div>\n  );\n};\n\nexport default TipModal;\n","import React from \"react\";\nimport \"./css/index.css\";\n\n// Placeholder to center flexbox alignment\nconst placeholderIcon = <div className=\"navbar-icon\"></div>;\n\nconst NavBar = ({ title, goBack }) => {\n  return (\n    <div className=\"navbar\">\n      {goBack ? (\n        <div className=\"navbar-icon\" onClick={goBack}>\n          <i className=\"fas fa-arrow-left\" />\n        </div>\n      ) : (\n        placeholderIcon\n      )}\n      <p className=\"navbar-title\">{title}</p>\n      {placeholderIcon}\n    </div>\n  );\n};\n\nexport default NavBar;\n","import React, {\n  Suspense,\n  useCallback,\n  useEffect,\n  useMemo,\n  useState\n} from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { useHistory, useParams } from \"react-router-dom\";\nimport {\n  getPinnedPost,\n  getUserAvatar,\n  getUserProfile,\n  resetUserData\n} from \"../../actions/UserActions\";\nimport { attachMedia } from \"../../utils/Torrents\";\nimport useOnlineStatus from \"../../hooks/useOnlineStatus\";\nimport Loader from \"../../common/Loader\";\nimport NavBar from \"../../common/NavBar\";\nimport av1 from \"../../images/av1.jpg\";\nimport \"./css/index.css\";\nimport TipModal from \"../../common/TipModal\";\n\nconst Post = React.lazy(() => import(\"../../common/Post\"));\nconst SharedPost = React.lazy(() => import(\"../../common/Post/SharedPost\"));\n\nconst PostPage = () => {\n  // Third-party hooks\n  const dispatch = useDispatch();\n  const { postId, type, userId } = useParams();\n  const history = useHistory();\n  const profile = useSelector(({ user }) => user.profile);\n  const pinnedPost = useSelector(({ user }) => user.wall?.pinnedPost);\n\n  // States\n  const [loading, setLoading] = useState(true);\n  const { isOnlineNode } = useOnlineStatus(userId);\n\n  // Memos\n  const username = useMemo(\n    () => profile.displayName ?? profile.alias ?? `POSTS`,\n    [profile.alias, profile.displayName]\n  );\n\n  // Callbacks\n  const fetchUser = useCallback(async () => {\n    dispatch(resetUserData());\n    await dispatch(getUserProfile(userId));\n    dispatch(getUserAvatar(userId));\n  }, [dispatch, userId]);\n\n  const fetchSelectedPost = useCallback(async () => {\n    dispatch(\n      getPinnedPost({\n        postId,\n        type,\n        publicKey: userId\n      })\n    );\n  }, [dispatch, postId, type, userId]);\n\n  const initializeData = useCallback(async () => {\n    setLoading(true);\n    await fetchUser();\n    fetchSelectedPost();\n    setLoading(false);\n  }, [fetchSelectedPost, fetchUser]);\n\n  const goBack = useCallback(() => {\n    history.push(`/${userId}`);\n  }, [history, userId]);\n\n  const renderPost = useCallback(\n    post => {\n      if (!post) {\n        return;\n      }\n\n      const avatar = profile.avatar\n        ? `data:image/png;base64,${profile.avatar}`\n        : av1;\n\n      if (post.type === \"shared\") {\n        return (\n          <Suspense\n            fallback={\n              <div className=\"post-loading\">\n                <Loader text=\"Loading Post...\" />\n              </div>\n            }\n            key={post.id}\n          >\n            <SharedPost\n              postID={post.id}\n              postPublicKey={post.originalAuthor}\n              sharedPostId={post.id}\n              sharedTimestamp={post.date}\n              sharerAvatar={avatar}\n              sharerPublicKey={userId}\n              sharerUsername={username}\n              isOnlineNode={isOnlineNode}\n            />\n          </Suspense>\n        );\n      }\n\n      if (post.type === \"post\") {\n        return (\n          <Suspense\n            fallback={\n              <div className=\"post-loading\">\n                <Loader text=\"Loading Post...\" />\n              </div>\n            }\n            key={post.id}\n          >\n            <Post\n              timestamp={post.date}\n              contentItems={post.contentItems}\n              username={username}\n              avatar={avatar}\n              publicKey={userId}\n              page={post.page}\n              id={post.id}\n              tipValue={post.tipValue ?? 0}\n              tipCounter={post.tipCounter ?? 0}\n              isOnlineNode={isOnlineNode}\n              pinned={true}\n            />\n          </Suspense>\n        );\n      }\n    },\n    [isOnlineNode, profile.avatar, userId, username]\n  );\n\n  // Effects\n  useEffect(() => {\n    initializeData();\n  }, [initializeData]);\n\n  if (loading) {\n    return <Loader text=\"Loading Post...\" />;\n  }\n\n  return (\n    <div className=\"post-page has-nav\">\n      <NavBar title={username} goBack={goBack} />\n      <div className=\"posts-container\">{renderPost(pinnedPost)}</div>\n      <TipModal publicKey={userId} />\n    </div>\n  );\n};\n\nexport default PostPage;\n"],"sourceRoot":""}