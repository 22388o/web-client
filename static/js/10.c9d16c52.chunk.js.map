{"version":3,"sources":["images/av1.jpg","hooks/useOnlineStatus.js","common/TipModal/index.js","images/banner-bg.jpg","images/lightning-logo.svg","common/Divider/index.js","pages/User/index.js","utils/Cache.js","utils/Promise.js","utils/Torrents.js"],"names":["module","exports","useOnlineStatus","publicKey","dispatch","useDispatch","profile","useSelector","user","useState","lastSeenApp","setLastSeenApp","lastSeenNode","setLastSeenNode","isOnlineApp","setIsOnlineApp","isOnlineNode","setIsOnlineNode","onlineCheckTimer","setOnlineCheckTimer","updateUserStatus","useCallback","onlineThreshold","Moment","utc","subtract","isSameOrAfter","useEffect","clearTimeout","timer","setTimeout","lastSeenAppListener","listenPath","path","gunPointer","gunUser","callback","event","lastSeenNodeListener","off","TipModalContent","React","lazy","TipModal","props","modalOpen","tip","close","closeModal","loader","useMemo","text","className","onClick","fallback","Divider","Post","SharedPost","UserPage","params","useParams","userId","wall","setUserLoading","wallLoading","setWallLoading","fetchUserData","a","resetUserData","getUserProfile","getUserHeader","getUserAvatar","console","error","fetchUserWall","log","resetUserWall","getUserWall","openTipModal","openModal","targetType","initializeUserWall","postId","type","getPinnedPost","displayNameListener","updateUserProfile","displayName","bioListener","bio","username","alias","renderPost","post","avatar","av1","Loader","key","id","postID","postPublicKey","originalAuthor","sharedPostId","sharedTimestamp","date","sharerAvatar","sharerPublicKey","sharerUsername","pinned","timestamp","contentItems","page","tipValue","tipCounter","style","backgroundImage","header","defaultBanner","color","opacity","cursor","data-tip","src","shockLogo","alt","backgroundColor","effect","pinnedPost","posts","map","getCachedFile","fileName","FileCache","_init","Promise","resolve","reject","init","then","persist","status","persistent","load","cachedFile","createURL","warn","renderCachedFile","fileURL","selector","elements","document","querySelectorAll","length","forEach","element","muted","autoplay","saveFile","buffer","save","runSerial","tasks","result","task","supportedFileTypes","formats","options","supportedFormats","Object","values","reduce","fileType","_getFileType","file","extension","name","split","slice","entries","filter","includes","supportedFileType","webTorrentClient","initializeClient","WebTorrent","default","getCacheId","renderTorrent","torrentMode","torrent","target","magnetURI","torrentElements","torrentElement","contentURL","decodeURIComponent","replace","format","toLowerCase","endsWith","compatibleURL","setAttribute","renderTo","attachMedia","all","supportedItems","item","getCacheFileName","get","add","files","thumbnails","match","thumbnailFileNames","sanitizedName","join","thumbnailName","thumbnailIndex","indexOf","thumbnailFile","thumbnailFileType","destroy","cachedThumbnail","on","getBlob","err","blob","querySelector","dataset","played","torrentTasks","torrents"],"mappings":"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","file":"static/js/10.c9d16c52.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/av1.48bf5c6a.jpg\";","import { useCallback, useEffect, useState } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport Moment from \"moment\";\nimport { gunUser, listenPath } from \"../utils/Gun\";\n\nconst ONLINE_INTERVAL = 30 * 1000;\n\nconst useOnlineStatus = publicKey => {\n  const dispatch = useDispatch();\n  const profile = useSelector(({ user }) => user.profile);\n\n  const [lastSeenApp, setLastSeenApp] = useState(false);\n  const [lastSeenNode, setLastSeenNode] = useState(false);\n  const [isOnlineApp, setIsOnlineApp] = useState(false);\n  const [isOnlineNode, setIsOnlineNode] = useState(false);\n  const [onlineCheckTimer, setOnlineCheckTimer] = useState();\n\n  const updateUserStatus = useCallback(() => {\n    const onlineThreshold = Moment.utc().subtract(1, \"minutes\");\n    const isOnlineNode =\n      Moment.utc(lastSeenNode).isSameOrAfter(onlineThreshold);\n    const isOnlineApp = Moment.utc(lastSeenApp).isSameOrAfter(onlineThreshold);\n\n    setIsOnlineNode(isOnlineNode);\n    setIsOnlineApp(isOnlineApp);\n  }, [lastSeenApp, lastSeenNode]);\n\n  useEffect(() => {\n    if (onlineCheckTimer) {\n      clearTimeout(onlineCheckTimer);\n    }\n\n    updateUserStatus();\n\n    const timer = setTimeout(() => {\n      updateUserStatus();\n    }, ONLINE_INTERVAL);\n\n    setOnlineCheckTimer(timer);\n\n    return () => clearTimeout(onlineCheckTimer);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [profile, updateUserStatus]);\n\n  useEffect(() => {\n    const lastSeenAppListener = listenPath({\n      path: \"Profile/lastSeenApp\",\n      gunPointer: gunUser(publicKey),\n      callback: event => {\n        setLastSeenApp(event);\n      }\n    });\n\n    const lastSeenNodeListener = listenPath({\n      path: \"Profile/lastSeenNode\",\n      gunPointer: gunUser(publicKey),\n      callback: event => {\n        setLastSeenNode(event);\n      }\n    });\n\n    return () => {\n      lastSeenAppListener.off();\n      lastSeenNodeListener.off();\n    };\n  }, [dispatch, publicKey]);\n\n  return {\n    isOnlineApp,\n    isOnlineNode\n  };\n};\n\nexport default useOnlineStatus;\n","import React, { Suspense, useCallback, useMemo } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { closeModal } from \"../../actions/TipActions\";\nimport Loader from \"../Loader\";\nimport \"./css/index.css\";\n\nconst TipModalContent = React.lazy(() => import(\"./components/Modal\"));\n\nconst TipModal = props => {\n  const dispatch = useDispatch();\n  const modalOpen = useSelector(({ tip }) => tip.modalOpen);\n\n  const close = useCallback(() => {\n    dispatch(closeModal());\n  }, [dispatch]);\n\n  const loader = useMemo(() => <Loader text=\"Loading...\" />, []);\n\n  if (!modalOpen) {\n    return null;\n  }\n\n  return (\n    <div className=\"modal-container\">\n      <div className=\"modal-overlay\" onClick={close}></div>\n      <div className=\"modal-content\">\n        <Suspense fallback={loader}>\n          <TipModalContent {...props} />\n        </Suspense>\n      </div>\n    </div>\n  );\n};\n\nexport default TipModal;\n","module.exports = __webpack_public_path__ + \"static/media/banner-bg.f59337b5.jpg\";","module.exports = __webpack_public_path__ + \"static/media/lightning-logo.ea3bd789.svg\";","import React from \"react\";\nimport \"./css/index.css\";\n\nconst Divider = ({ text }) => {\n  return (\n    <div className=\"divider-container\">\n      <div className=\"dash\" />\n      <p className=\"divider-text\">{text}</p>\n      <div className=\"dash\" />\n    </div>\n  );\n};\n\nexport default Divider;\n","import React, { useEffect, useState, useCallback, Suspense } from \"react\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport { useParams } from \"react-router-dom\";\nimport Tooltip from \"react-tooltip\";\n\nimport {\n  getUserWall,\n  resetUserWall,\n  resetUserData,\n  getUserProfile,\n  getUserAvatar,\n  updateUserProfile,\n  getUserHeader,\n  getPinnedPost\n} from \"../../actions/UserActions\";\nimport { openModal } from \"../../actions/TipActions\";\nimport useOnlineStatus from \"../../hooks/useOnlineStatus\";\nimport { listenPath, gunUser } from \"../../utils/Gun\";\nimport { attachMedia } from \"../../utils/Torrents\";\n\nimport Loader from \"../../common/Loader\";\nimport Divider from \"../../common/Divider\";\nimport TipModal from \"../../common/TipModal\";\n\n// Assets\nimport defaultBanner from \"../../images/banner-bg.jpg\";\nimport av1 from \"../../images/av1.jpg\";\nimport shockLogo from \"../../images/lightning-logo.svg\";\nimport \"./css/index.css\";\n\nconst Post = React.lazy(() => import(\"../../common/Post\"));\nconst SharedPost = React.lazy(() => import(\"../../common/Post/SharedPost\"));\n\nconst UserPage = () => {\n  const dispatch = useDispatch();\n  const params = useParams();\n  const { userId: publicKey } = params;\n  const wall = useSelector(({ user }) => user.wall);\n  const profile = useSelector(({ user }) => user.profile);\n  const { isOnlineApp, isOnlineNode } = useOnlineStatus(publicKey);\n  // Reserved for future use\n  // eslint-disable-next-line no-unused-vars\n  const [userLoading, setUserLoading] = useState(true);\n  const [wallLoading, setWallLoading] = useState(true);\n\n  const fetchUserData = useCallback(async () => {\n    try {\n      setUserLoading(true);\n      dispatch(resetUserData());\n      await dispatch(getUserProfile(publicKey));\n      setUserLoading(false);\n      // Load user avatar in the background\n      dispatch(getUserHeader(publicKey));\n      dispatch(getUserAvatar(publicKey));\n    } catch (err) {\n      console.error(err);\n      setUserLoading(false);\n    }\n  }, [dispatch, publicKey]);\n\n  const fetchUserWall = useCallback(async () => {\n    try {\n      console.log(\"Setting Loading status to:\", true);\n      setWallLoading(true);\n      dispatch(resetUserWall());\n      await dispatch(getUserWall(publicKey));\n      console.log(\"Setting Loading status to:\", false);\n      setWallLoading(false);\n    } catch (err) {\n      console.error(err);\n      console.log(\"Setting Loading status to:\", false);\n      setWallLoading(false);\n    }\n  }, [dispatch, publicKey]);\n\n  const openTipModal = useCallback(() => {\n    dispatch(openModal({ targetType: \"spontaneousPayment\" }));\n  }, [dispatch]);\n\n  const initializeUserWall = useCallback(async () => {\n    const { postId, userId, type } = params;\n    await fetchUserData();\n    fetchUserWall();\n\n    dispatch(\n      getPinnedPost({\n        postId,\n        publicKey: userId,\n        type\n      })\n    );\n  }, [dispatch, fetchUserData, fetchUserWall, params]);\n\n  useEffect(() => {\n    initializeUserWall();\n\n    // Subscribe for updates\n    const displayNameListener = listenPath({\n      path: \"Profile/displayName\",\n      gunPointer: gunUser(publicKey),\n      callback: event => {\n        dispatch(updateUserProfile({ displayName: event }));\n      }\n    });\n\n    const bioListener = listenPath({\n      path: \"Profile/bio\",\n      gunPointer: gunUser(publicKey),\n      callback: event => {\n        dispatch(updateUserProfile({ bio: event }));\n      }\n    });\n\n    return () => {\n      displayNameListener.off();\n      bioListener.off();\n    };\n  }, [dispatch, initializeUserWall, publicKey]);\n\n  // useEffect(() => {\n  //   attachMedia(\n  //     wall.posts.filter(post => post.type === \"post\"),\n  //     false\n  //   );\n  // }, [wall.posts]);\n\n  const username = profile.displayName ?? profile.alias;\n\n  const renderPost = useCallback(\n    post => {\n      if (!post) {\n        return;\n      }\n\n      const avatar = profile.avatar\n        ? `data:image/png;base64,${profile.avatar}`\n        : av1;\n\n      if (post.type === \"shared\") {\n        return (\n          <Suspense\n            fallback={\n              <div className=\"post-loading\">\n                <Loader text=\"Loading Post...\" />\n              </div>\n            }\n            key={post.id}\n          >\n            <SharedPost\n              postID={post.id}\n              postPublicKey={post.originalAuthor}\n              sharedPostId={post.id}\n              sharedTimestamp={post.date}\n              sharerAvatar={avatar}\n              sharerPublicKey={publicKey}\n              sharerUsername={username}\n              isOnlineNode={isOnlineNode}\n              pinned={post.pinned}\n            />\n          </Suspense>\n        );\n      }\n\n      if (post.type === \"post\") {\n        return (\n          <Suspense\n            fallback={\n              <div className=\"post-loading\">\n                <Loader text=\"Loading Post...\" />\n              </div>\n            }\n            key={post.id}\n          >\n            <Post\n              timestamp={post.date}\n              contentItems={post.contentItems}\n              username={username}\n              avatar={avatar}\n              publicKey={publicKey}\n              page={post.page}\n              id={post.id}\n              tipValue={post.tipValue ?? 0}\n              tipCounter={post.tipCounter ?? 0}\n              isOnlineNode={isOnlineNode}\n              pinned={post.pinned}\n              post={post}\n            />\n          </Suspense>\n        );\n      }\n    },\n    [isOnlineNode, profile.avatar, publicKey, username]\n  );\n\n  return (\n    <div className=\"user-page\">\n      <div\n        className=\"top-banner\"\n        style={{\n          backgroundImage: `url(${\n            profile.header\n              ? `data:image/png;base64,${profile.header}`\n              : defaultBanner\n          })`\n        }}\n      ></div>\n      <div className=\"user-details\">\n        <div\n          className=\"main-av\"\n          style={{\n            backgroundImage: `url(${\n              profile.avatar ? `data:image/png;base64,${profile.avatar}` : av1\n            })`\n          }}\n        ></div>\n\n        <div className=\"details\">\n          <div className=\"user-info\">\n            <p className=\"username\">{username}</p>\n\n            <div className=\"activity\">\n              <p\n                className=\"status\"\n                style={{\n                  color: isOnlineApp\n                    ? \"#01a33d\"\n                    : isOnlineNode\n                    ? \"#f2a900\"\n                    : \"#888\"\n                }}\n              >\n                {isOnlineApp\n                  ? \"Active Recently\"\n                  : isOnlineNode\n                  ? \"Node Online\"\n                  : \"Node Offline\"}\n              </p>\n            </div>\n\n            {profile.bio ? (\n              <div className=\"desc\">\n                <p className=\"title\">Bio</p>\n                <p>{profile.bio}</p>\n              </div>\n            ) : null}\n          </div>\n\n          <div\n            className=\"send-tip-btn\"\n            onClick={openTipModal}\n            style={{\n              opacity: isOnlineNode ? 1 : 0.5,\n              cursor: isOnlineNode ? \"pointer\" : \"default\"\n            }}\n            data-tip={\n              !isOnlineNode ? \"You can only tip users with online nodes\" : null\n            }\n          >\n            <img src={shockLogo} alt=\"Bitcoin Lightning\" />\n            <p>Send Tip</p>\n          </div>\n\n          <Tooltip backgroundColor=\"#3a4d67\" effect=\"solid\" />\n        </div>\n      </div>\n\n      <div className=\"tabs-holder\">\n        <p className=\"tab active\">Feed</p>\n      </div>\n      <div className=\"posts-holder\">\n        {renderPost(wall.pinnedPost)}\n        {wall.pinnedPost && <Divider text=\"More Posts\" />}\n        {wall.posts.map(renderPost)}\n      </div>\n      {wallLoading ? (\n        <Loader text={`Loading ${wall.page >= 0 ? \"More\" : \"Wall\"} Posts...`} />\n      ) : null}\n      <TipModal publicKey={publicKey} />\n    </div>\n  );\n};\n\nexport default UserPage;\n","import FileCache from \"browser-file-storage\";\n\nexport const DB_NAME = \"ShockWalletStore\";\n\nexport const init = () =>\n  new Promise((resolve, reject) => {\n    FileCache.init(DB_NAME)\n      .then(() => {\n        console.log(\"File cache initialized!\");\n        return FileCache.persist();\n      })\n      .then(status => {\n        if (status.persistent) {\n          resolve(status);\n        } else {\n          reject(status);\n        }\n      });\n  });\n\nexport const getCachedFile = async fileName => {\n  try {\n    if (!FileCache._init) {\n      await init();\n    }\n\n    const cachedFile = await FileCache.load(fileName);\n    return cachedFile.createURL();\n  } catch (err) {\n    console.warn(err);\n    return false;\n  }\n};\n\nexport const renderCachedFile = (fileURL, selector) => {\n  const elements = document.querySelectorAll(selector);\n  if (elements && elements.length) {\n    elements.forEach(element => {\n      element.src = fileURL;\n      element.muted = true;\n      element.autoplay = true;\n    });\n  }\n  return !!elements && !!elements.length;\n};\n\nexport const saveFile = (fileName, buffer) => {\n  return FileCache.save(fileName, buffer);\n};\n","export const runSerial = tasks => {\n  let result = Promise.resolve();\n  tasks.forEach(task => {\n    result = result.then(() => task());\n  });\n  return result;\n};\n","import { getCachedFile, renderCachedFile, saveFile } from \"./Cache\";\nimport { runSerial } from \"./Promise\";\n\nexport const supportedFileTypes = {\n  \"video/embedded\": {\n    formats: [\"mp4\", \"webm\"],\n    element: \"video\",\n    options: {\n      autoplay: true,\n      muted: true\n    }\n  },\n  \"image/embedded\": {\n    formats: [\"jpg\", \"png\", \"webp\", \"jpeg\"],\n    element: \"img\",\n    options: {}\n  }\n};\n\nexport const supportedFormats = Object.values(supportedFileTypes).reduce(\n  (supportedFormats, fileType) => [...supportedFormats, ...fileType.formats],\n  []\n);\n\nconst _getFileType = file => {\n  const extension = file.name?.split(\".\")?.slice(-1)[0];\n  const [supportedFileType] = Object.entries(supportedFileTypes).filter(\n    ([type, options]) => options.formats.includes(extension)\n  );\n\n  if (supportedFileType) {\n    const [name, fileType] = supportedFileType;\n    return {\n      name,\n      ...fileType\n    };\n  }\n\n  return null;\n};\n\nexport let webTorrentClient = null;\n\nexport const initializeClient = async () => {\n  if (!webTorrentClient) {\n    const WebTorrent = await import(\"webtorrent\");\n    webTorrentClient = new WebTorrent.default();\n  }\n\n  return webTorrentClient;\n};\n\nconst getCacheId =\n  ({ id, key }) =>\n  file =>\n    `${id}-${key}-${file.name}`;\n\nconst renderTorrent = ({ file, type, torrentMode, torrent }) => {\n  const element = type.element;\n  const target = `${element}[data-torrent=\"${torrent.magnetURI}\"]`;\n  const torrentElements = document.querySelectorAll(target);\n  console.log(\"Torrent Elements:\", torrentElements);\n  torrentElements.forEach(torrentElement => {\n    const contentURL = decodeURIComponent(\n      torrent.magnetURI.replace(/.*(ws=)/gi, \"\")\n    );\n    const [compatibleURL] = type.formats.filter(format =>\n      contentURL.toLowerCase().endsWith(`.${format.toLowerCase()}`)\n    );\n\n    if (torrentMode || !compatibleURL) {\n      file.renderTo(torrentElement, type.options);\n      return;\n    }\n\n    torrentElement.setAttribute(\"src\", contentURL);\n  });\n};\n\nexport const attachMedia = async (posts = [], torrentMode = true) => {\n  const torrentTasks = await Promise.all(\n    posts.map(async post => {\n      const { contentItems, id } = post;\n      const supportedItems = Object.entries(contentItems).filter(\n        ([, item]) => supportedFileTypes[item.type]\n      );\n\n      if (!supportedItems) {\n        return [];\n      }\n\n      const webTorrentClient = await initializeClient();\n\n      return supportedItems.map(\n        ([key, item]) =>\n          () =>\n            new Promise(resolve => {\n              const getCacheFileName = getCacheId({ id, key });\n              const torrentExists = webTorrentClient.get(item.magnetURI);\n\n              if (torrentExists) {\n                resolve(true);\n                return;\n              }\n\n              webTorrentClient.add(item.magnetURI, async torrent => {\n                // Proceed to the next torrent in queue\n                resolve(true);\n\n                const files = torrent.files.filter(file => {\n                  const extension = file.name?.split(\".\")?.slice(-1)[0];\n                  const supportedFileType = Object.entries(\n                    supportedFileTypes\n                  ).filter(([, options]) =>\n                    options.formats.includes(extension)\n                  )[0];\n                  if (supportedFileType) {\n                    const [, fileType] = supportedFileType;\n                    const matched = fileType.formats.includes(extension);\n                    return matched;\n                  }\n                  return false;\n                });\n\n                const thumbnails = files.filter(file =>\n                  file.name.match(/-thumb\\.([\\w\\d]){2,4}$/gi)\n                );\n                const thumbnailFileNames = thumbnails.map(file =>\n                  file.name.replace(/\\.([\\w\\d]){2,4}$/gi, \"\")\n                );\n\n                files.map(async file => {\n                  // Skip thumbnails\n                  if (thumbnailFileNames.includes(file.name)) {\n                    return;\n                  }\n\n                  const fileType = _getFileType(file);\n\n                  if (!fileType) {\n                    return;\n                  }\n\n                  const fileName = getCacheFileName(file);\n\n                  const element = fileType.element;\n                  const target = `${element}[data-torrent=\"${item.magnetURI}\"]`;\n                  const cachedFile = await getCachedFile(fileName);\n                  // Find thumbnail\n                  const sanitizedName = fileName\n                    .split(\".\")\n                    .slice(0, -1)\n                    .join(\".\");\n                  const thumbnailName = `${sanitizedName}-thumb`;\n                  const thumbnailIndex =\n                    thumbnailFileNames.indexOf(thumbnailName);\n                  const thumbnailFile = thumbnails[thumbnailIndex];\n                  const thumbnailFileType = thumbnailFile\n                    ? _getFileType(thumbnailFile)\n                    : null;\n\n                  if (cachedFile) {\n                    const torrent = webTorrentClient.get(item.magnetURI);\n\n                    if (torrent) {\n                      torrent.destroy();\n                    }\n\n                    if (element === \"video\" && thumbnailFile) {\n                      const target = `${thumbnailFileType.element}[data-torrent=\"${item.magnetURI}\"]`;\n                      const cachedThumbnail = await getCachedFile(\n                        getCacheFileName(thumbnailFile)\n                      );\n\n                      renderCachedFile(cachedThumbnail, target);\n                    }\n\n                    renderCachedFile(cachedFile, target);\n                    return;\n                  }\n\n                  renderTorrent({\n                    file,\n                    type: fileType,\n                    torrentMode,\n                    torrent: item\n                  });\n\n                  if (thumbnailFile) {\n                    renderTorrent({\n                      file: thumbnailFile,\n                      type: thumbnailFileType,\n                      torrentMode,\n                      torrent: item\n                    });\n                  }\n                });\n\n                torrent.on(\"done\", () => {\n                  files.map(file => {\n                    const fileType = _getFileType(file);\n                    const fileName = getCacheFileName(file);\n                    const element = fileType.element;\n                    const target = `${element}[data-torrent=\"${item.magnetURI}\"]`;\n\n                    file.getBlob(async (err, blob) => {\n                      if (err) {\n                        console.warn(err);\n                        return;\n                      }\n\n                      console.log(\"Caching loaded file...\", fileName, blob);\n                      await saveFile(fileName, blob);\n                      const element = document.querySelector(target);\n                      if (element.dataset.played === \"false\") {\n                        const cachedFile = await getCachedFile(fileName);\n                        renderCachedFile(cachedFile, target);\n                      }\n                    });\n                  });\n                });\n              });\n            })\n      );\n    })\n  );\n  const contentItems = torrentTasks.reduce(\n    (torrents, contentItems) => [...torrents, ...contentItems],\n    []\n  );\n\n  runSerial(contentItems);\n};\n"],"sourceRoot":""}